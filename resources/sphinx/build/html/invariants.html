
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Invariants &#8212; FLBTools  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Optimizer" href="optimizer.html" />
    <link rel="prev" title="tools.cpc" href="generated/tools.cpc.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-tools.invariants">
<span id="invariants"></span><h1>Invariants<a class="headerlink" href="#module-tools.invariants" title="Permalink to this heading">¶</a></h1>
<p><strong>A collection of tools for analyzing AMM invariant functions</strong></p>
<p>This package contains a collection of tools for analyzing
AMM invariant functions. The focus of this package lies on
AMMs with hyperbolic invariants, ie invariants of the form</p>
<div class="math notranslate nohighlight">
\[x\cdot y = k\]</div>
<p>where k is a constant and x,y are – potentially virtual –
token balances of an AMM. This was the invariant function
used in the first ever AMM, Bancor, and it was taken over by
Uniswap and many others. In levered form it is the invariant
used in Uniswap v3 as well as in Bancor’s Carbon.</p>
<p>The core objects in this package are the <cite>Invariant</cite> and the
<cite>Function</cite> as well as <cite>FunctionVector</cite> objects.</p>
<ul class="simple">
<li><p>the <cite>Invariant</cite> object describes an invariant in the
non-isolated form <span class="math notranslate nohighlight">\(k=k(x,y)\)</span> that is by definition
available for all invariant based AMMs</p></li>
<li><p>the <cite>Function</cite> describes the <em>swap function</em> 
<span class="math notranslate nohighlight">\(y=f(x,k)\)</span> that is obtained from the invariant
equation by isolating y, which may or may not be
analytically available for a given invariant.</p></li>
<li><p>the <cite>FunctionVector</cite> object finally describes a vector
of <cite>Function</cite> objects, together with an integration
kernel (see below) thereby effectively defining a vector
space of functions together with a number of norms.</p></li>
</ul>
<p>In addition to those higher level objects, the package also
contains a number of more fundamental objects that are used
as building blocks for those higher level objects. These
include</p>
<ul class="simple">
<li><p>the <cite>Kernel</cite> object represents an <em>integration kernel</em>, ie
a weight function together with a domain of integration;
this object serves to define <span class="math notranslate nohighlight">\(L_p\)</span> norms on the
functions defined above, and therefore ultimately to measure
distances</p></li>
<li><p>the <cite>DictVector</cite> object implements sparse vector
functionality using dicts where the dict keys are
considered the vector space dimensions, and the values
the associated coefficients. Note that any allowable
dict key is a valid dimension.</p></li>
</ul>
<section id="module-tools.invariants.functions">
<span id="functions"></span><h2>Functions<a class="headerlink" href="#module-tools.invariants.functions" title="Permalink to this heading">¶</a></h2>
<p><strong>object representing a function y = f(x; params)</strong></p>
<p>(c) Copyright Bprotocol foundation 2024. 
Licensed under MIT</p>
<section id="function">
<h3>Function<a class="headerlink" href="#function" title="Permalink to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tools.invariants.functions.Function">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tools.invariants.functions.</span></span><span class="sig-name descname"><span class="pre">Function</span></span><a class="headerlink" href="#tools.invariants.functions.Function" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>represent a function `y = f(x; params)`</strong></p>
<p>EXAMPLE USAGE</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">functions</span> <span class="k">as</span> <span class="nn">f</span>

<span class="nd">@f</span><span class="o">.</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">MyFunction</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">MyFunction</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">mf</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>       <span class="c1"># 0.4142</span>
<span class="n">mf</span><span class="o">.</span><span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>     <span class="c1"># 0.3536</span>
<span class="n">mf</span><span class="o">.</span><span class="n">pp</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>    <span class="c1"># -0.0883</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.d2f_dx2_abs">
<span class="sig-name descname"><span class="pre">d2f_dx2_abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.d2f_dx2_abs" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>calculates the second derivative of f(x) at x with abs step size h*precision</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.d2f_dx2_rel">
<span class="sig-name descname"><span class="pre">d2f_dx2_rel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.d2f_dx2_rel" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>calculates the second derivative of f(x) at x with relative step size eta (h=x*eta*precision)</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.df_dx">
<span class="sig-name descname"><span class="pre">df_dx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.df_dx" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>first derivative (alias  -p)</strong></p>
<p>note: this function calls <cite>p</cite> and it should not be overridden</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.df_dx_abs">
<span class="sig-name descname"><span class="pre">df_dx_abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.df_dx_abs" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>calculates the derivative of f(x) at x with abs step size h*precision</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.df_dx_rel">
<span class="sig-name descname"><span class="pre">df_dx_rel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.df_dx_rel" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>calculates the derivative of f(x) at x with relative step size eta (h=x*eta*precision)</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.f">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">f</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.f" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>returns y = f(x; k) [to be implemented by subclass]</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> – input value x (token balance)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>output value y (other token balance)</p>
</dd>
</dl>
<p>this function must be implemented by the subclass as
it specifies the actual function other parameters –
notably the pool constant k – will usually be parts
of the (dataclass) constructor</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.p">
<span class="sig-name descname"><span class="pre">p</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.p" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>price function (alias for -df_dx_xxx)</strong></p>
<p>Note: this function CAN be overridden by the subclass if it can be
calculated analytically in this case the precision parameter should be
ignored</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.p_func">
<span class="sig-name descname"><span class="pre">p_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.p_func" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>returns the derivative as a function object</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.params">
<span class="sig-name descname"><span class="pre">params</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.params" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>returns the parameters of the function as a dictionary</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.pp">
<span class="sig-name descname"><span class="pre">pp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.pp" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>derivative of the price function (alias for -d2f_dx2_xxx)</strong></p>
<p>Note: this function does not call <cite>p</cite> but goes via <cite>d2f_dx2_xxx</cite>; if <cite>p</cite>
is overrriden then it may make sense to override this function as well</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.pp_func">
<span class="sig-name descname"><span class="pre">pp_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.pp_func" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>returns the second derivative as a function object</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.update" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>returns a copy of the function, with the given parameters updated</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>kwargs</strong> – parameters to update</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="functionvector">
<h3>FunctionVector<a class="headerlink" href="#functionvector" title="Permalink to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tools.invariants.functions.</span></span><span class="sig-name descname"><span class="pre">FunctionVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tools.invariants.kernel.Kernel" title="tools.invariants.kernel.Kernel"><span class="pre">Kernel</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>a vector of functions</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>kernel</strong> – the integration kernel to use (default: Kernel())</p>
</dd>
</dl>
<p>A function vector is a linear combination of Function objects. It exposes
the usual <strong>vector properties</strong> (technically it is a <cite>DictVector</cite> subclass) where
the functions themselves used as dict keys and therefore the <em>dimensions</em> of the 
vector space. Note that there is an additional constraint the only vectors that
have the same kernel can be aggregated.</p>
<p>It also exposes properties related to <strong>pointwise evaluation</strong> of the functions, notably
the function value of the vector at point x is given as</p>
<div class="math notranslate nohighlight">
\[f_v(x) = \sum_i \alpha_i * f_i(x)\]</div>
<p>and this carries over to the price functions an derivatives that are exposed
in the <cite>p</cite>, <cite>df_dx</cite>, <cite>pp</cite> etc methods.</p>
<p>Finally it exposes properties related to <strong>integration</strong> of the functions
based on the kernel, notably the <cite>integrate</cite> method that integrates the
vector of functions as well as various norms and distance measures.</p>
<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.apply_kernel">
<span class="sig-name descname"><span class="pre">apply_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.apply_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>returns func multiplied by the kernel value (as value or lambda if x is None)</strong></p>
<p>USAGE</p>
<p>this function can either be called directly</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fv</span> <span class="o">=</span> <span class="n">FunctionVector</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">fv</span><span class="o">.</span><span class="n">apply_kernel</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c1"># ==&gt; value</span>
</pre></div>
</div>
<p>or be used to create a new function</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fv</span> <span class="o">=</span> <span class="n">FunctionVector</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">func_kernel</span> <span class="o">=</span> <span class="n">fv</span><span class="o">.</span><span class="n">apply_kernel</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="c1"># ==&gt; lambda </span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.bump">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bump</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.bump" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>bumps dct[k] by +h; everything else unmodified (returns a new dict)</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.curve_fit">
<span class="sig-name descname"><span class="pre">curve_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.curve_fit" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>fits a function to self using gradient descent</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – function to fit (typically a Function object) (1)</p></li>
<li><p><strong>params0</strong> – starting parameters (dict) (1)</p></li>
<li><p><strong>kwargs</strong> – passed to self.minimize</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the parameters of the fitted function (dict)</p>
</dd>
</dl>
<p>NOTE 1: The func object must have and update method that accepts a dict of parameters
with the keys of <cite>params0</cite> and returns a new object with the updated parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.df_dx">
<span class="sig-name descname"><span class="pre">df_dx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.df_dx" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>derivative of `self.f` (alias for -p)</strong></p>
<p>..math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\<span class="n">frac</span><span class="p">{</span><span class="n">df</span><span class="p">}{</span><span class="n">dx</span><span class="p">}(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> \<span class="n">sum_i</span> \<span class="n">alpha_i</span> <span class="o">*</span> \<span class="n">frac</span><span class="p">{</span><span class="n">df_i</span><span class="p">}{</span><span class="n">dx</span><span class="p">}(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.distance" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>calculates the distance between self and func (L2 norm)</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.distance2">
<span class="sig-name descname"><span class="pre">distance2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.distance2" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>calculates the distance^2 between self and func (L2 norm)</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.e_i">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">e_i</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.e_i" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>returns the i’th unit vector of size n</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.e_k">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">e_k</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.e_k" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>returns the unit vector of key k in dct</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.f">
<span class="sig-name descname"><span class="pre">f</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.f" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>returns the function value</strong></p>
<div class="math notranslate nohighlight">
\[f(x) = \sum_i \alpha_i * f_i(x)\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.f_k">
<span class="sig-name descname"><span class="pre">f_k</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.f_k" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>alias for `self.apply_kernel(self.f, x)`</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.f_r">
<span class="sig-name descname"><span class="pre">f_r</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.f_r" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>alias for `self.restricted(self.f, x)`</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.goalseek">
<span class="sig-name descname"><span class="pre">goalseek</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.goalseek" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>very simple gradient descent implementation for a goal seek</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> – target value (default: 0)</p></li>
<li><p><strong>x0</strong> – starting estimate</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.integrate">
<span class="sig-name descname"><span class="pre">integrate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>integrates `self.f` using the kernel [convenience access for integrate_func(func=None)]</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.integrate_func">
<span class="sig-name descname"><span class="pre">integrate_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.integrate_func" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>integrates func (default: `self.f`) using the kernel</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.minimize">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">minimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learning_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deriv_h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.minimize" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>minimizes the function `func` using gradient descent (multiple dimensions)</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – function to be minimized</p></li>
<li><p><strong>x0</strong> – starting point (np.array-like or dct (1))</p></li>
<li><p><strong>learning_rate</strong> – optimization parameter (float; default cls.MM_LEARNING_RATE)</p></li>
<li><p><strong>iterations</strong> – max iterations (int; default cls.MM_ITERATIONS)</p></li>
<li><p><strong>tolerance</strong> – convergence tolerance (float; default cls.MM_TOLERANCE)</p></li>
<li><p><strong>deriv_h</strong> – step size for derivative calculation (float; default cls.MM_DERIV_H)</p></li>
<li><p><strong>return_path</strong> – if True, returns the entire optimization path (list of np.array)
as well as the last dfdx (np.array); in this case, the result is 
the last element of the path</p></li>
</ul>
</dd>
</dl>
<p>NOTE 1: if x0 is np=array-like or None, then func will be called with positional arguments
and the result will be returned as an np.array. if x0 is a dict, then func will be
called with keyword arguments and the result will be returned as a dict</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.minimize1">
<span class="sig-name descname"><span class="pre">minimize1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learning_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.minimize1" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>minimizes the function using gradient descent</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x0</strong> – starting estimate (float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.norm" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>calculates the norm of self (L2 norm)</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.norm2">
<span class="sig-name descname"><span class="pre">norm2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.norm2" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>calculates the norm^2 of self (L2 norm)</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.p">
<span class="sig-name descname"><span class="pre">p</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.p" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>returns :math:`sum_i alpha_i * p_i(x)` where :math:`p_i` is the price function of :math:`f_i`</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.plot" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>plots the function</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – function to plot (default: self.f_r)</p></li>
<li><p><strong>x_min</strong> – lower bound (default: self.kernel.x_min)</p></li>
<li><p><strong>x_max</strong> – upper bound (default: self.kernel.x_max)</p></li>
<li><p><strong>steps</strong> – number of steps (default: np.linspace defaults)</p></li>
<li><p><strong>show</strong> – whether to call plt.show() (default: True)</p></li>
<li><p><strong>grid</strong> – whether to show a grid (default: True)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the result of plt.plot</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.pp">
<span class="sig-name descname"><span class="pre">pp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.pp" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>derivative of the price function of `self.f`</strong></p>
<dl class="simple">
<dt>..math::</dt><dd><p>pp(x) = sum_i alpha_i * pp_i(x)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.restricted">
<span class="sig-name descname"><span class="pre">restricted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.restricted" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>returns func(x) restricted to the domain of self.kernel (as value or lambda if x is None)</strong></p>
<p>USAGE</p>
<p>this function can either be called directly</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fv</span> <span class="o">=</span> <span class="n">FunctionVector</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">fv</span><span class="o">.</span><span class="n">restricted</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c1"># ==&gt; value</span>
</pre></div>
</div>
<p>or be used to create a new function</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fv</span> <span class="o">=</span> <span class="n">FunctionVector</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">func_restricted</span> <span class="o">=</span> <span class="n">fv</span><span class="o">.</span><span class="n">restricted</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="c1"># ==&gt; lambda </span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.wrap">
<span class="sig-name descname"><span class="pre">wrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.wrap" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>creates a FunctionVector from a function using the same kernel as self</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>func</strong> – the function to wrap (a Function object)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a new FunctionVector object wrapping <cite>func</cite>, with the same kernel as <cite>self</cite></p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fv0</span> <span class="o">=</span> <span class="n">FunctionVector</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="n">mykernel</span><span class="p">)</span>       <span class="c1"># creates a FV with a specific kernel</span>
<span class="n">f</span>   <span class="o">=</span> <span class="n">MyFunction</span><span class="p">()</span>                          <span class="c1"># creates a Function object</span>
<span class="n">fv0</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>                                 <span class="c1"># a FV object with the same kernel as fv0</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="module-tools.invariants.invariant">
<span id="invariant"></span><h2>Invariant<a class="headerlink" href="#module-tools.invariants.invariant" title="Permalink to this heading">¶</a></h2>
<p><strong>Represents an AMM invariant</strong></p>
<p>An AMM invariant is a function <span class="math notranslate nohighlight">\(k(x, y)\)</span> that is constant for all x, y in
the AMM, typically expressed in a form like <span class="math notranslate nohighlight">\(x\cdot y = k\)</span>. This is
distinct from the swap function <span class="math notranslate nohighlight">\(y=f(x, k)\)</span> which is obtained from the
invariant by isolating y.</p>
<p>Usually working with the swap function is more convenient. However, in some cases
the invariant can be computed analytically whilst the swap function can not. The
<cite>Invariant</cite> object for example allows to estimate the swap function numerically
based on the invariant alone.</p>
<dl class="py class">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tools.invariants.invariant.</span></span><span class="sig-name descname"><span class="pre">Invariant</span></span><a class="headerlink" href="#tools.invariants.invariant.Invariant" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Represents an AMM invariant</strong></p>
<p>This class is an abstract base class that represents an arbitrary AMM invariant. In order
to obtain a usuable invariant object, one must subclass this class and implement the
<cite>k_func</cite> method. For example the following code snippet shows how to implement a simple
constant product invariant:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ConstantProductInvariant</span><span class="p">(</span><span class="n">Invariant</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">k_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span>

<span class="n">cpi</span> <span class="o">=</span> <span class="n">ConstantProductInvariant</span><span class="p">()</span>
<span class="n">cpi</span><span class="o">.</span><span class="n">y_func</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>  <span class="c1"># returns ~5 (calculated numerically)</span>
</pre></div>
</div>
<p>The constant product invariant is analytically very easy to handle, and therefore a better
implementation would be to also implement the <cite>y_Func</cite> method, which returns the swap function
as a <cite>Function</cite> object. This is shown in the following code snippet:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ConstantProductSwapFunction</span><span class="p">(</span><span class="n">Function</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">/</span> <span class="n">x</span>

<span class="k">class</span> <span class="nc">ConstantProductInvariant2</span><span class="p">(</span><span class="n">Invariant</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">k_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span>

    <span class="n">YFUNC_CLASS</span> <span class="o">=</span> <span class="n">ConstantProductSwapFunction</span>

<span class="n">cpi</span> <span class="o">=</span> <span class="n">ConstantProductInvariant2</span><span class="p">()</span>
<span class="n">cpi</span><span class="o">.</span><span class="n">y_func</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>  <span class="c1"># returns 5 (calculated analytically)</span>
</pre></div>
</div>
<dl class="py exception">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant.ConvergenceError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ConvergenceError</span></span><a class="headerlink" href="#tools.invariants.invariant.Invariant.ConvergenceError" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>raised when a goal seek fails to converge</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant.goalseek_bisect">
<span class="sig-name descname"><span class="pre">goalseek_bisect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_lo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_hi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.invariant.Invariant.goalseek_bisect" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>bisect implementation for goal seek</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – function for goal seek, eg <cite>lambda x: x**2-1</cite></p></li>
<li><p><strong>target</strong> – target value (default: 0)</p></li>
<li><p><strong>x_lo</strong> – lower bound on x (default: GSBS_XLO=1e-10)</p></li>
<li><p><strong>x_hi</strong> – upper bound on x (default: GSBS_XHI=1e10)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>x</cite> such that <cite>func(x)</cite> is close to target (1)</p>
</dd>
</dl>
<p>NOTE 1: raises <cite>ConvergenceError</cite> if it fails to converge</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant.goalseek_gradient">
<span class="sig-name descname"><span class="pre">goalseek_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.invariant.Invariant.goalseek_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>very simple gradient descent implementation for a goal seek</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – function for goal seek, eg <cite>lambda x: x**2-1</cite></p></li>
<li><p><strong>target</strong> – target value (default: 0)</p></li>
<li><p><strong>x0</strong> – starting estimate</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>x</cite> such that <cite>func(x)</cite> is close to target (1)</p>
</dd>
</dl>
<p>NOTE 1: raises <cite>ConvergenceError</cite> if it fails to converge</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant.k_func">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">k_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.invariant.Invariant.k_func" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>returns invariant value k = k(x, y)</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant.p_func">
<span class="sig-name descname"><span class="pre">p_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.invariant.Invariant.p_func" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>returns p = -dy/dx = p(x, k)</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – token balance x</p></li>
<li><p><strong>k</strong> – pool invariant k</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>price function p = -y’(x, k) (1)</p>
</dd>
</dl>
<p>NOTE 1: this currently only works if y_func is analytic, in which case
the value returned is <cite>self.y_Func(k=k).p(x)</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant.y_Func">
<span class="sig-name descname"><span class="pre">y_Func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.invariant.Invariant.y_Func" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>returns y = y(x=.; k) as a Function object (may also return None)</strong></p>
<p>USAGE</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">y_func</span> <span class="o">=</span> <span class="n">y_Func</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">y_func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant.y_func">
<span class="sig-name descname"><span class="pre">y_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.invariant.Invariant.y_func" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>returns y = y(x,k)</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – token balance x</p></li>
<li><p><strong>k</strong> – pool invariant k</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>token balance y = y(x, k) (1)</p>
</dd>
</dl>
<p>NOTE 1: y is calculated from <cite>y_Func</cite> if possible or numerically via
<cite>y_func_from_k_func</cite> otherwise</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant.y_func_from_k_func">
<span class="sig-name descname"><span class="pre">y_func_from_k_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_lo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_hi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.invariant.Invariant.y_func_from_k_func" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>solves y = y(x, k) from k = k(x, y)</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> – starting estimate (for gradient, default = 1)</p></li>
<li><p><strong>x_hi</strong> – upper bound (for bisect, default = 1e10)</p></li>
<li><p><strong>x_lo</strong> – ditto lower (default = 1e-10)</p></li>
<li><p><strong>method</strong> – one of GS_GRADIENT (default) or GS_BISECT</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant.y_func_is_analytic">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">y_func_is_analytic</span></span><a class="headerlink" href="#tools.invariants.invariant.Invariant.y_func_is_analytic" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>whether y_func is obtained as an analytic calculation (ie, not via y_func_from_k_func)</strong></p>
</dd></dl>

</dd></dl>

</section>
<section id="helpers">
<h2>Helpers<a class="headerlink" href="#helpers" title="Permalink to this heading">¶</a></h2>
<section id="module-tools.invariants.vector">
<span id="vector"></span><h3>Vector<a class="headerlink" href="#module-tools.invariants.vector" title="Permalink to this heading">¶</a></h3>
<p>Implements the <cite>DictVector</cite> class, a sparse vector based on dicts</p>
<dl class="py class">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tools.invariants.vector.</span></span><span class="sig-name descname"><span class="pre">DictVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>A sparse vector where dict keys are dimensions and values are coefficients</strong></p>
<p>USAGE</p>
<p>below an incomplete list of operations that can be performed; note that most
dunder methods are actually implemented, so the usual arithmetic operations
can be performed</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">v1</span> <span class="o">=</span> <span class="n">DictVector</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>      <span class="c1"># use kwargs</span>

<span class="n">d2</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">DictVector</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">d2</span><span class="p">)</span>                 <span class="c1"># use dict</span>

<span class="n">v1</span><span class="o">+</span><span class="n">v2</span>                                   <span class="c1"># {a: 11, b: 22, c: 33}</span>
<span class="n">v2</span><span class="o">-</span><span class="n">v1</span>                                   <span class="c1"># {a: 9, b: 18, c: 27}</span>
<span class="mi">2</span><span class="o">*</span><span class="n">v1</span>                                    <span class="c1"># {a: 2, b: 4, c: 6}</span>
<span class="n">v1</span><span class="o">.</span><span class="n">enorm</span>                                <span class="c1"># = sqrt(1+4+9) ~ 3.74</span>
<span class="n">v1</span> <span class="o">==</span> <span class="n">v2</span>                                <span class="c1"># False</span>
<span class="nb">len</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>                                 <span class="c1"># 3</span>

<span class="n">v</span> <span class="o">=</span> <span class="n">DictVector</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">v</span> <span class="o">+=</span> <span class="n">v1</span>
<span class="n">v</span> <span class="o">==</span> <span class="n">DictVector</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># True</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.dict_add">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict_add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector.dict_add" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Adds two dict-vectors `a` and `b`</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.dict_eq">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict_eq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector.dict_eq" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Calculates whether two dict-vectors `a` and `b` are equal (within `eps`, on absolute value basis)</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.dict_norm">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector.dict_norm" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Calculates the Euclidian norm of dict-vector `a`</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.dict_smul">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict_smul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector.dict_smul" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Multiplies dict-vector `a` by scalar `s`</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.dict_sprod">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict_sprod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector.dict_sprod" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Multiplies two dict-vectors `a` and `b` (scalar product)</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.dict_sub">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict_sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector.dict_sub" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Subtracts two dict-vectors `a` and `b`</strong></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.enorm">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">enorm</span></span><a class="headerlink" href="#tools.invariants.vector.DictVector.enorm" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Returns Euclidian norm of `self`</strong></p>
<div class="math notranslate nohighlight">
\[n_e = \sqrt{\sum_i \alpha_i^2}\]</div>
<p>EXAMPLE</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">DictVector</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">v</span><span class="o">.</span><span class="n">enorm</span>                         <span class="c1"># = sqrt(3^2 + 4^2) = 5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.n">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">single_dict_argument</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector.n" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Creates a new DictVector from `kwargs`</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.new">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">new</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">single_dict_argument</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector.new" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Creates a new DictVector from `kwargs`</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.null">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">null</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector.null" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Creates a *null* DictVector, aka an empty dict</strong></p>
</dd></dl>

</dd></dl>

</section>
<section id="module-tools.invariants.kernel">
<span id="kernel"></span><h3>Kernel<a class="headerlink" href="#module-tools.invariants.kernel" title="Permalink to this heading">¶</a></h3>
<p><strong>Implements the `Kernel` class, an integration kernel together with numeric integration code</strong></p>
<dl class="py class">
<dt class="sig sig-object py" id="tools.invariants.kernel.Kernel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tools.invariants.kernel.</span></span><span class="sig-name descname"><span class="pre">Kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_min</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_max</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">callable</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'builtin-flat'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'trapezoid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.kernel.Kernel" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Represents a one-dimensional integration kernel and provides numeric integration code</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_min</strong> – minimum x value for integration</p></li>
<li><p><strong>x_max</strong> – ditto maximum</p></li>
<li><p><strong>kernel</strong> – kernel function (should be positive, and defined <cite>x_min</cite> &lt;= <cite>x</cite> &lt;= <cite>x_max</cite>);
generically, the kernel function is a callable taking a single argument;
alternatively there are a number of built-in kernels that can be selected 
by passing the respective constant (see table)</p></li>
<li><p><strong>method</strong> – integration method (currently only <cite>METHOD_TRAPEZOID</cite>)</p></li>
<li><p><strong>steps</strong> – number of steps for integration</p></li>
</ul>
</dd>
</dl>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><cite>kernel</cite></p></th>
<th class="head"><p>meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>FLAT</p></td>
<td><p>constant</p></td>
</tr>
<tr class="row-odd"><td><p>TRIANGLE</p></td>
<td><p>triangle</p></td>
</tr>
<tr class="row-even"><td><p>SAWTOOTHL, SAWTOOTHR</p></td>
<td><p>sawtooth left/right</p></td>
</tr>
<tr class="row-odd"><td><p>GAUSS, GAUSSW, GAUSSN</p></td>
<td><p>gaussian (fitted, wide, narrow)</p></td>
</tr>
</tbody>
</table>
<p>USAGE</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">k</span> <span class="o">=</span> <span class="n">Kernel</span><span class="p">(</span><span class="n">x_min</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">Kernel</span><span class="o">.</span><span class="n">FLAT</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>

<span class="n">k</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>                  <span class="c1"># 0.5</span>
<span class="n">k</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>          <span class="c1"># ~0.6666</span>

<span class="n">Kernel</span><span class="o">.</span><span class="n">integrate_trapezoid</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># ~0.6666</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="tools.invariants.kernel.Kernel.domain">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">domain</span></span><a class="headerlink" href="#tools.invariants.kernel.Kernel.domain" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Convenience accessor for `(x_min, x_max)`</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.kernel.Kernel.in_domain">
<span class="sig-name descname"><span class="pre">in_domain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.kernel.Kernel.in_domain" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Returns True iff x is in the integration domain `x_min`…`x_max`</strong></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.kernel.Kernel.integrate">
<span class="sig-name descname"><span class="pre">integrate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.kernel.Kernel.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Integrates `func` against the kernel (calls `integrate_trapezoid`)</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – function to integrate (single variable)</p></li>
<li><p><strong>steps</strong> – number of steps for integration (default: self.steps)</p></li>
<li><p><strong>method</strong> – integration method (default: self.method) (1)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\int_{x_{min}}^{x_{max}} \mathrm{func}(x)\,\mathrm{kernel}(x)\,dx\)</span></p>
</dd>
</dl>
<p>NOTE 1: currently the only method supported is <cite>METHOD_TRAPEZOID</cite></p>
<p>EXAMPLE</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">k</span> <span class="o">=</span> <span class="n">Kernel</span><span class="p">(</span><span class="n">x_min</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">Kernel</span><span class="o">.</span><span class="n">FLAT</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
<span class="n">k</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>          <span class="c1"># ~0.6666</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.kernel.Kernel.integrate_trapezoid">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">integrate_trapezoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.kernel.Kernel.integrate_trapezoid" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Integrates a function using the trapezoid method between `x_min` and `x_max`</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – function to integrate (single variable callable)</p></li>
<li><p><strong>x_min</strong> – minimum x value for integration</p></li>
<li><p><strong>x_max</strong> – ditto maximum</p></li>
<li><p><strong>steps</strong> – number of steps for integration</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\int_{x_{min}}^{x_{max}} \mathrm{func}(x)\,dx\)</span></p>
</dd>
</dl>
<p>EXAMPLE</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
<span class="n">Kernel</span><span class="o">.</span><span class="n">integrate_trapezoid</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># ~0.6666</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.kernel.Kernel.k">
<span class="sig-name descname"><span class="pre">k</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.kernel.Kernel.k" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Alias for `self.kernel(x)`, but set to zero beyond `x_min`, `x_max`</strong></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tools.invariants.kernel.Kernel.limits">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">limits</span></span><a class="headerlink" href="#tools.invariants.kernel.Kernel.limits" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Convenience accessor for `(x_min, x_max)`</strong></p>
</dd></dl>

</dd></dl>

</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">FLBTools</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="analyzer.html">Analyzer</a></li>
<li class="toctree-l1"><a class="reference internal" href="arbgraphs.html">ArbGraphs (<cite>arbgraphs</cite> module)</a></li>
<li class="toctree-l1"><a class="reference internal" href="cpc.html">CPC</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Invariants</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-tools.invariants.functions">Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#function">Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functionvector">FunctionVector</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-tools.invariants.invariant">Invariant</a></li>
<li class="toctree-l2"><a class="reference internal" href="#helpers">Helpers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-tools.invariants.vector">Vector</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-tools.invariants.kernel">Kernel</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="optimizer.html">Optimizer</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="generated/tools.cpc.html" title="previous chapter">tools.cpc</a></li>
      <li>Next: <a href="optimizer.html" title="next chapter">Optimizer</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023-24, Bprotocol foundation.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/invariants.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>